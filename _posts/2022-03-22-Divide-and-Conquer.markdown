---
layout: post
title:  "Divide and Conquer"
date:   2022-03-22 10:57:44 +0900
categories: jekyll update
---

## 분할 정복 알고리즘 (Divide and Conquer)
### 분할 정복 알고리즘
분할 정복 알고리즘은 문제의 입력을 분할하여 문제를 해결하는 방식의 알고리즘이다.<br>
분할된 입력에 대한 문제(부분문제)를 해결하여 얻은 해(부분해)를 취합해서 원래의 문제에 대한 해를 얻는다.

### 분할 정복 알고리즘의 종류
#### 합병 정렬 (Merge Sort)
합병 정렬은 입력을 계속해서 반으로 분할하고, 분할된 입력을 정렬하고 합병하는 과정을 반복한다.<br>
 합병은 2개의 각각 정렬된 숫자들을 1개의 정렬된 숫자들로 합치는 것을 말한다.<br>
```
	37  10  22  30  35  13  25  24
→ (37  10  22  30)  /  (35  13  25  24)
→ (37  10)  /  (22  30)  /  (35  13  25  24)
→ (37)  /  (10)  /  (22  30)  /  (35  13  25  24)
→ (10  37)  /  (22  30)  /  (35  13  25  24)
→ (10  37)  /  (22)  /  (30)  /  (35  13  25  24)
→ (10  37)  /  (22  30)  /  (35  13  25  24)
→ (10  22  30  37)  /  (35  13  25  24)
→ (10  22  30  37)  /  (35  13)  /  (25  24)
.
.
.
```
위와 같은 방식으로 진행된다.<br>
분할하는 부분은 O(1), 합병하는 부분은 O(n + m)의 시간이 걸린다.(n, m은 각각 정렬된 배열의 크기)<br>
합병정렬의 시간 복잡도는 O(*n*log*n*)이다.

#### 퀵 정렬 (Quick Sort)
퀵정렬은 정복 후 분할을 하는 알고리즘이며, 각 부분문제의 크기가 일정하지 않다.<br>
먼저 기준역할을 하는 피봇(pivot) 원소를 하나 정하고, 피봇보다 작은 숫자는 왼쪽, 큰 숫자는 오른쪽에 놓아 분할하고, 피봇을 그 사이에 놓는다. 이후에 분할된 부분문제들에 대해서도 같은 과정을 반복하여 정렬한다.<br>
```
	6  3  11  9  12  2  **8**  15  18  10  7  14
→ **8**  3  11  9  12  2  6  15  18  10  7  14		(피봇을 맨 앞으로)
→ **8**  3  7  6  2  12  9  15  18  10  11  14		(피봇보다 큰 수와 작을 수를 교환)
→ 2  3  7  6  **8**  12  9  15  18  10  11  14		(피봇을 작은 수 중 가장 오른쪽에 있는 수와 교환)
.
.
.
```
위와 같은 과정을 각 부분문제에 대해서도 반복한다.
피봇으로 항상 작은 숫자가 선택되는 최악의 경우 시간복잡도는 O(n^2) 이다.
피봇이 입력을 항상 2등분으로 분할하는 최선의 경우의 시간복잡도는 O(*n*log2*n*)이다.
피봇을 랜덤하게 선택한다고 가정했을 때의 시간 복잡도는 최선의 경우와 같다.

피봇을 선정하는 방법들이 있다. 먼저 랜덤으로 선정하는 방법이 있고, 양 끝의 숫자와 중간 숫자 중에서 중앙값으로 정하는 방법, 입력을 3등분한 후 2번째의 방법으로 중앙값을 찾아서 각 중앙값들의 중앙값을 피봇으로 설정하는 방법이 있다.

#### 선택 문제 (Selection)
선택 문제는 n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제이다.
이 문제를 해결하기 위한 몇가지 방법이 있지만, 분할 정복 개념을 활용하면 다음과 같이 해결할 수 있다.
```
k=7의 경우

	6  3  11  9  12  2  **8**  15  18  10  7  14	(퀵 정렬과 같이 피봇을 정하고 원소들의 위치를 교환한다)
→ 2  3  7  6  **8**  12  9  15  18  10  11  14
→ 12  9  15  18  10  11  14				(7보다 크기가 작은 small group은 버리고 나머지 그룹에 k-(small group의 크기 + 1)의 문제를 본다)
.
.
.
```
위의 경우에서 small group의 크기가 k-1이 된다면 피봇이 찾는 숫자가 된다.
선택 문제 알고리즘의 평균 경우 시간복잡도는 O(n)이다.

#### 최근접 점의 쌍 찾기 (Closest Pair)
최근접 점의 쌍을 찾는 문제는 2차원 평면상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제이다.
이 문제 또한 각 점의 거리를 모두 계산하는 등의 방법이 있지만, 분할 정복 개념을 활용하여 보다 효율적으로 문제를 해결할 수 있다.

n개의 점을 2등분 분할하여 각각의 부분문제에서 최근접 점의 쌍을 찾고, 2개의 부분해 중에서 짧은 거리를 가진 점의 쌍을 찾는다.
그리고 왼쪽 부분문제의 점과 오른쪽 부분문제의 점의 거리 또한 고려해야 하므로 짧은 부분해의 거리만큼 중간영역을 정해서 중간영역의 점들 중에서 최근점 점의 쌍이 있는지 확인한다.

이 알고리즘의 시간복잡도는 O(*n*log^2*n*)이다. 최근접 점의 쌍을 찾는 알고리즘은 컴퓨터 그래픽스, 컴퓨터 비전, 지리 정보 시스템, 마케팅 등의 여러 분야에 사용된다.